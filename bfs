import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

/**
 * Main class to run the BFS example.
 */
public class BfsExample {

    public static void main(String[] args) {
        // Create a graph with 7 vertices
        Graph g = new Graph(7);

        // Add edges to the graph
        g.addEdge(0, 1);
        g.addEdge(0, 2);
        g.addEdge(1, 3);
        g.addEdge(1, 4);
        g.addEdge(2, 5);
        g.addEdge(2, 6);

        /*
         * The graph looks like this:
         *
         * 0
         * / \
         * 1   2
         * / \ / \
         * 3  4 5  6
         */

        // Perform BFS starting from vertex 0
        System.out.println("Starting BFS from node 0:");
        g.BFS(0);
    }
}

/**
 * Class to represent a graph using an adjacency list.
 */
class Graph {
    private int V; // Number of vertices
    private List<List<Integer>> adj; // Adjacency list

    /**
     * Constructor
     * @param v Number of vertices
     */
    public Graph(int v) {
        V = v;
        adj = new LinkedList<>();
        for (int i = 0; i < v; ++i) {
            adj.add(new LinkedList<>());
        }
    }

    /**
     * Function to add an edge to the graph (directed)
     * @param v The source vertex
     * @param w The destination vertex
     */
    public void addEdge(int v, int w) {
        adj.get(v).add(w);
    }

    /**
     * Performs BFS traversal starting from a given source vertex.
     * @param startNode The vertex to start the search from
     */
    public void BFS(int startNode) {
        // 1. Create a boolean array to track visited vertices.
        // All are initialized to false by default.
        boolean[] visited = new boolean[V];

        // 2. Create a Queue for the BFS.
        Queue<Integer> queue = new LinkedList<>();

        // 3. Mark the starting node as visited and add it to the queue.
        visited[startNode] = true;
        queue.add(startNode);

        // 4. Loop as long as the queue is not empty.
        while (!queue.isEmpty()) {

            // 5. Dequeue a vertex from the queue and print it.
            int currentNode = queue.poll();
            System.out.print(currentNode + " ");

            // 6. Get all adjacent vertices of the dequeued vertex.
            for (int neighbor : adj.get(currentNode)) {

                // 7. If a neighbor has not been visited:
                if (!visited[neighbor]) {
                    // Mark it as visited
                    visited[neighbor] = true;
                    // Enqueue it
                    queue.add(neighbor);
                }
            }
        }
        System.out.println("\nBFS complete.");
    }
}
